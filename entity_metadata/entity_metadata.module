<?php
// $Id$

/**
 * @file
 * Module file for the deprecated entity metadata module. It contains only
 * deprecated functions, which are there to ease upgrading to the entity.module.
 *
 * Modules should make use of the new functions only, as the deprecated
 * functions will be removed in the near future.
 */

/**
 * Deprecated, but still here to ease upgrading.
 * Do not make use of this function, instead use the new one.
 */
function entity_metadata_get_info($entity_type = NULL) {
  return entity_get_property_info($entity_type);
}

/**
 * Deprecated, but still here to ease upgrading.
 * Do not make use of this function, instead use the new one.
 */
function entity_metadata_get_properties($entity_type = NULL) {
  return entity_get_all_property_info($entity_type);
}

/**
 * Deprecated, but still here to ease upgrading.
 * Do not make use of this function, instead use the new one.
 */
function entity_metadata_info_cache_clear() {
  entity_property_info_cache_clear();
}

/**
 * Deprecated, but still here to ease upgrading.
 * Do not make use of this function, instead use the new one.
 */
function entity_metadata_list_extract_type($type) {
  return entity_property_list_extract_type($type);
}

/**
 * Deprecated, but still here to ease upgrading.
 * Do not make use of this function, instead use the new one.
 */
function entity_metadata_verbatim_get($data, array $options, $name) {
  return entity_property_verbatim_get($data, $options, $name);
}

/**
 * Deprecated, but still here to ease upgrading.
 * Do not make use of this function, instead use the new one.
 */
function entity_metadata_verbatim_set($data, $name, $value) {
  return entity_property_verbatim_set($data, $name, $value);
}

/**
 * Deprecated, but still here to ease upgrading.
 * Do not make use of this function, instead use the new one.
 */
function entity_metadata_getter_method($object, array $options, $name) {
  return entity_property_getter_method($object, $options, $name);
}

/**
 * Deprecated, but still here to ease upgrading.
 * Do not make use of this function, instead use the new one.
 */
function entity_metadata_setter_method($object, $name, $value) {
  entity_property_setter_method($object, $name, $value);
}

/**
 * Deprecated, but still here to ease upgrading.
 * Do not make use of this function, instead use the new one.
 */
function entity_metadata_get_list($data, array $options, $name) {
  return entity_property_get_list($data, $options, $name);
}

/**
 * Deprecated, but still here to ease upgrading.
 * Do not make use of this function, instead use the new one.
 */
function entity_metadata_validate_integer_positive($value) {
  return entity_property_validate_integer_positive($value);
}

/**
 * Deprecated, but still here to ease upgrading.
 * Do not make use of this function, instead use the new one.
 */
function entity_metadata_validate_integer_non_negative($value) {
  return entity_property_validate_integer_non_negative($value);
}













/**
 * Determines whether the given user has access to an entity.
 *
 * @param $op
 *   The operation being performed. One of 'view', 'update', 'create' or
 *   'delete'.
 * @param $entity_type
 *   The entity type of the entity to check for.
 * @param $entity
 *   Optionally an entity to check access for. If no entity is given, it will be
 *   determined whether access is allowed for all entities of the given type.
 * @param $account
 *   The user to check for. Leave it to NULL to check for the global user.
 * @return boolean
 *   Whether access is allowed or not. If no information is available, NULL is
 *   returned.
 */
function entity_metadata_entity_access($op, $entity_type, $entity = NULL, $account = NULL) {
  if (($info = entity_get_info()) && isset($info[$entity_type]['access callback'])) {
    return $info[$entity_type]['access callback']($op, $entity, $account, $entity_type);
  }
}

/**
 * Permanently save the given entity.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $entity
 *   The entity to save.
 * @return
 *   FALSE, if there were no information how to save the entity.
 */
function entity_metadata_entity_save($entity_type, &$entity) {
  $info = entity_get_info($entity_type);
  if (isset($info['save callback'])) {
    $info['save callback']($entity);
  }
  elseif (entity_metadata_entity_type_supports($entity_type, 'save')) {
    entity_save($entity_type, $entity);
  }
  else {
    return FALSE;
  }
}

/**
 * Permanently delete the given entity.
 *
 * Note: This is no hook_entity_delete() implementation. See
 * entity_metadata_module_implements_alter().
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $id
 *   The uniform identifier of the entity to delete.
 * @return
 *   FALSE, if there were no information how to delete the entity.
 *
 * @see entity_metadata_module_implements_alter()
 */
function entity_metadata_entity_delete($entity_type, $id) {
  $info = entity_get_info($entity_type);
  if (isset($info['deletion callback'])) {
    $info['deletion callback']($id);
  }
  elseif (entity_metadata_entity_type_supports($entity_type, 'delete')) {
    entity_delete($entity_type, $id);
  }
  else {
    return FALSE;
  }
}

/**
 * Implements hook_module_implements_alter().
 *
 * Avoid an undesired implementations of hook_entity_delete() and
 * hook_entity_view().
 */
function entity_metadata_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'entity_delete' || $hook == 'entity_view') {
    unset($implementations['entity_metadata']);
  }
}

/**
 * Creates a new entity instance of the given type.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $values
 *   An array of values for properties to set for the new entity. At least the
 *   properties marked as 'required' in the property info have to be passed.
 * @return EntityDrupalWrapper
 *   An EntityDrupalWrapper wrapping the newly created entity or FALSE, if
 *   there were no information how to create the entity.
 */
function entity_metadata_entity_create($entity_type, $values = array()) {
  $info = entity_get_info($entity_type);
  if (isset($info['creation callback'])) {
    return $info['creation callback']($values, $entity_type);
  }
  elseif (entity_metadata_entity_type_supports($entity_type, 'create')) {
    return entity_metadata_wrapper($entity_type, entity_create($entity_type, $values));
  }
  return FALSE;
}

/**
 * Generate an array for rendering the given entities.
 *
 * Note: This is no hook_entity_view() implementation. See
 * entity_metadata_module_implements_alter().
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $entities
 *   An array of entities to render, keyed by their ids. E.g. as returned from
 *   entity_load().
 * @param $view_mode
 *   A view mode as used by this entity type, e.g. 'full', 'teaser'...
 * @param $langcode
 *   (optional) A language code to use for rendering. Defaults to the global
 *   content language of the current request.
 * @return
 *   The renderable array or FALSE if there were no information how to view the
 *   entity.
 */
function entity_metadata_entity_view($entity_type, $entities, $view_mode = 'full', $langcode = NULL) {
  $info = entity_get_info($entity_type);
  if (isset($info['view callback'])) {
    return $info['view callback']($entities, $view_mode, $langcode, $entity_type);
  }
  elseif (entity_metadata_entity_type_supports($entity_type, 'view')) {
    return entity_view($entity_type, $entities, $view_mode, $langcode);
  }
  return FALSE;
}

/**
 * Determines whether for the given entity type a given operation is available.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $op
 *   One of 'create', 'view', 'save', 'delete' or 'access.
 */
function entity_metadata_entity_type_supports($entity_type, $op) {
  $info = entity_get_info($entity_type);
  $keys = array(
    'view' => 'view callback',
    'create' => 'creation callback',
    'delete' => 'deletion callback',
    'save' => 'save callback',
    'access' => 'access callback',
  );
  if (isset($info[$keys[$op]]) || in_array('EntityAPIControllerInterface', class_implements($info['controller class']))) {
    return TRUE;
  }
}


/**
 * Queries for entities having the given property value.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $property
 *   The name of the property to query for.
 * @param $value
 *   A property value or an array of possible values to query for.
 * @param $limit
 *   Limit the numer of results. Defaults to 30.
 * @return
 *   An array of entity ids or NULL if there is no information how to query for
 *   the given property.
 */
function entity_metadata_entity_query($entity_type, $property, $value, $limit = 30) {
  $properties = entity_metadata_get_properties($entity_type);
  if (isset($properties[$property]['query callback'])) {
    return $properties[$property]['query callback']($entity_type, $property, $value, $limit);
  }
}














/**
 * Defines the properties for the text_formatted data structure.
 */
function entity_metadata_text_formatted_properties() {
  return array(
    'value' => array(
      'type' => 'text',
      'label' => t('Text'),
      'sanitized' => TRUE,
      'getter callback' => 'entity_metadata_field_text_get',
      'raw getter callback' => 'entity_metadata_verbatim_get',
    ),
    'format' => array(
      'type' => 'token',
      'label' => t('Text format'),
      'options list' => 'entity_metadata_field_text_formats',
      'getter callback' => 'entity_metadata_verbatim_get',
    ),
  );
}

/**
 * Verifies that the given data can be safely used as the given type regardless
 * of the PHP variable type of $data. Example: the string "15" is a valid
 * integer, but "15nodes" is not.
 *
 * @return
 *   Whether the data is valid for the given type.
 */
function entity_metadata_verify_data_type($data, $type) {
  // First off check for entities, which may be represented by their ids too.
  $info = entity_get_info();
  if (isset($info[$type])) {
    $nameKey = isset($info[$type]['entity keys']['name']);
    return is_object($data) || ($nameKey && entity_metadata_verify_data_type($data, 'token')) || (!$nameKey  && entity_metadata_verify_data_type($data, 'integer'));
  }

  switch ($type) {
    case 'unknown':
      return TRUE;
    case 'date':
    case 'duration':
    case 'integer':
      return is_numeric($data) && strpos($data, '.') === FALSE;
    case 'decimal':
      return is_numeric($data);
    case 'text':
      return is_scalar($data);
    case 'token':
      return is_scalar($data) && preg_match('!^[a-z][a-z0-9_]*$!', $data);
    case 'boolean':
      return is_scalar($data) && (is_bool($data) || $data == 0 || $data == 1);
    case 'uri':
      return valid_url($data, TRUE);
    case 'list':
      return (is_array($data) && array_values($data) == $data) || (is_object($data) && $data instanceof EntityMetadataArrayObject);
    default:
    case 'struct':
      return is_object($data) || is_array($data);
  }
}

/**
 * Converts the schema information available for the given table to property info.
 *
 * @param $table
 *   The name of the table as used in hook_schema().
 * @return
 *   An array of property info as suiting for hook_entity_property_info().
 */
function entity_metadata_convert_schema($table) {
  $schema = drupal_get_schema($table);
  $properties = array();
  foreach ($schema['fields'] as $name => $info) {
    if ($type = _entity_metadata_convert_schema_type($info['type'])) {
      $properties[$name] = array(
        'type' => $type,
        'label' => drupal_ucfirst($name),
        'query callback' => 'entity_metadata_table_query',
        // As we cannot know about any setter access, leave out the setter
        // callback. For getting usually no further access callback is needed.
      );
      if ($type == 'serial') {
        $properties[$name]['validation callback'] = 'entity_metadata_validate_integer_positive';
      }
    }
  }
  return $properties;
}

function _entity_metadata_convert_schema_type($type) {
  switch ($type) {
    case 'int':
    case 'serial':
      return 'integer';
    case 'float':
    case 'numeric':
      return 'decimal';
    case 'char':
    case 'varchar':
    case 'text':
      return 'text';
  }
}
